'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getArgsNumber = exports.optionsByType = exports.groupByType = exports.getOptions = exports.toArray = exports.CommandNotFoundError = exports.MissingRequiredArgsError = undefined;
exports.validateCommand = validateCommand;
exports.findOptions = findOptions;
exports.isCommand = isCommand;
exports.isNamespace = isNamespace;
exports.isOptions = isOptions;
exports.findByAlias = findByAlias;
exports.findNext = findNext;
exports.find = find;
exports.run = run;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _es6Error = require('es6-error');

var _es6Error2 = _interopRequireDefault(_es6Error);

var _ramda = require('ramda');

var _minimist = require('minimist');

var _minimist2 = _interopRequireDefault(_minimist);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MissingRequiredArgsError = exports.MissingRequiredArgsError = function (_ExtendableError) {
  _inherits(MissingRequiredArgsError, _ExtendableError);

  function MissingRequiredArgsError() {
    _classCallCheck(this, MissingRequiredArgsError);

    return _possibleConstructorReturn(this, (MissingRequiredArgsError.__proto__ || Object.getPrototypeOf(MissingRequiredArgsError)).apply(this, arguments));
  }

  return MissingRequiredArgsError;
}(_es6Error2.default);

var CommandNotFoundError = exports.CommandNotFoundError = function (_ExtendableError2) {
  _inherits(CommandNotFoundError, _ExtendableError2);

  function CommandNotFoundError() {
    _classCallCheck(this, CommandNotFoundError);

    return _possibleConstructorReturn(this, (CommandNotFoundError.__proto__ || Object.getPrototypeOf(CommandNotFoundError)).apply(this, arguments));
  }

  return CommandNotFoundError;
}(_es6Error2.default);

var toArray = exports.toArray = function toArray(a) {
  return Array.isArray(a) ? a : a == null ? [] : [a];
};

var getOptions = exports.getOptions = (0, _ramda.reduce)(function (r, o) {
  return (0, _ramda.flatten)([r, (0, _ramda.map)(toArray, [o.short, o.long])]);
}, []);

var groupByType = exports.groupByType = (0, _ramda.groupBy)((0, _ramda.prop)('type'));

var optionsByType = exports.optionsByType = (0, _ramda.compose)((0, _ramda.map)(getOptions), groupByType);

var getArgsNumber = exports.getArgsNumber = (0, _ramda.pipe)((0, _ramda.props)(['requiredArgs', 'optionalArgs']), _ramda.flatten, (0, _ramda.reject)(_ramda.isNil), _ramda.length);

function validateCommand(command, args) {
  if (!command || !isCommand(command)) {
    throw new CommandNotFoundError();
  }
  if (toArray(command.requiredArgs).length > args.length) {
    throw new MissingRequiredArgsError(command.requiredArgs);
  }
  return command;
}

function findOptions(node) {
  return node.options || [];
}

function isCommand(node) {
  return !(0, _ramda.isNil)(node) && (node.handler || node.options || node.requiredArgs || node.optionalArgs || node.alias || node.description) && node;
}

function isNamespace(node) {
  return (0, _ramda.type)(node) === 'Object' && (0, _ramda.any)(function (v) {
    return isCommand(v);
  }, (0, _ramda.values)(node)) && node;
}

function isOptions(node) {
  return Array.isArray(node) && node;
}

function findByAlias(key, node) {
  return (0, _ramda.find)((0, _ramda.propEq)('alias', key), (0, _ramda.values)(node));
}

function findNext(key, node) {
  if (!key) {
    return null;
  }
  var next = node[key] || findByAlias(key, node);
  return next;
}

function find(node, argv) {
  if (!node.path) {
    node.path = '.';
  }

  (0, _ramda.forEachObjIndexed)(function (child, key) {
    if (isCommand(child) || isNamespace(child)) {
      child.path = node.path + '/' + key;
    }
  }, node);

  var _argv = _toArray(argv),
      head = _argv[0],
      tail = _argv.slice(1);

  var next = findNext(head, node);
  var nextIsNamespace = isNamespace(next);
  var nextIsCommand = isCommand(next);

  // Prioritize following namespaces
  if (nextIsNamespace || nextIsCommand) {
    return find(next, tail);
  }

  var parsedArgv = (0, _minimist2.default)(argv, optionsByType(findOptions(node)));
  var givenArgs = parsedArgv._.slice(0);
  var command = validateCommand(node, givenArgs);
  var argsNumber = getArgsNumber(command);
  var givenArgsNumber = givenArgs.length;

  var filledArgs = givenArgs.slice(0, argsNumber);
  if (givenArgsNumber < argsNumber) {
    filledArgs.push.apply(filledArgs, _toConsumableArray(new Array(argsNumber - givenArgsNumber).fill(undefined)));
  }

  return {
    command: command,
    node: node,
    args: filledArgs.concat(parsedArgv)
  };
}

function loadModule(path) {
  return require(path).default || require(path);
}

function run(_ref, root) {
  var command = _ref.command,
      args = _ref.args;

  var handler = void 0;
  if (typeof command.handler === 'function') {
    handler = command.handler;
  } else if (typeof command.handler === 'string') {
    handler = loadModule(_path2.default.join(root, command.handler));
  } else if (typeof command.handler === 'undefined') {
    handler = loadModule(_path2.default.join(root, command.path));
  }

  return handler.apply(this, args);
}