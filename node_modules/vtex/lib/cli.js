#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const chalk_1 = __importDefault(require("chalk"));
const clear_module_1 = require("clear-module");
const findhelp_1 = require("findhelp");
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const ramda_1 = require("ramda");
require("v8-compile-cache");
const pkg = __importStar(require("../package.json"));
const CLIPrechecker_js_1 = require("./CLIPrechecker.js");
const conf = __importStar(require("./conf"));
const env_1 = require("./env");
const errors_1 = require("./errors");
const logger_1 = __importDefault(require("./logger"));
const tree_1 = __importDefault(require("./modules/tree"));
const nps_1 = require("./nps");
const Token_js_1 = require("./Token.js");
const update_1 = __importDefault(require("./update"));
const utils_1 = require("./utils");
const run = command => Promise.resolve(findhelp_1.run.call(tree_1.default, command, path_1.default.join(__dirname, 'modules')));
const logToolbeltVersion = () => {
    logger_1.default.debug(`Toolbelt version: ${pkg.version}`);
};
const loginCmd = tree_1.default.login;
let loginPending = false;
const checkLogin = args => {
    const first = args[0];
    const whitelist = [undefined, 'config', 'login', 'logout', 'switch', 'whoami', 'init', '-v', '--version', 'release'];
    const token = new Token_js_1.Token(conf.getToken());
    if (!token.isValid() && whitelist.indexOf(first) === -1) {
        logger_1.default.debug('Requesting login before command:', args.join(' '));
        return run({ command: loginCmd });
    }
};
const main = async () => {
    const args = process.argv.slice(2);
    conf.saveEnvironment(conf.Environment.Production); // Just to be backwards compatible with who used staging previously
    logToolbeltVersion();
    logger_1.default.debug('node %s - %s %s', process.version, os_1.default.platform(), os_1.default.release());
    logger_1.default.debug(args);
    await checkLogin(args);
    const command = await findhelp_1.find(tree_1.default, ramda_1.without([utils_1.VERBOSE], args));
    if (utils_1.isVerbose) {
        const findWhoami = await findhelp_1.find(tree_1.default, ['whoami']);
        if (command.command !== findWhoami.command) {
            await run(findWhoami);
        }
    }
    await nps_1.checkAndOpenNPSLink();
    await run(command);
};
const onError = e => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const status = (_b = (_a = e) === null || _a === void 0 ? void 0 : _a.response) === null || _b === void 0 ? void 0 : _b.status;
    const statusText = (_d = (_c = e) === null || _c === void 0 ? void 0 : _c.response) === null || _d === void 0 ? void 0 : _d.statusText;
    const headers = (_f = (_e = e) === null || _e === void 0 ? void 0 : _e.response) === null || _f === void 0 ? void 0 : _f.headers;
    const data = (_h = (_g = e) === null || _g === void 0 ? void 0 : _g.response) === null || _h === void 0 ? void 0 : _h.data;
    const code = ((_j = e) === null || _j === void 0 ? void 0 : _j.code) || null;
    if (headers) {
        logger_1.default.debug('Failed request headers:', headers);
    }
    if (status) {
        if (status === 401) {
            if (!loginPending) {
                logger_1.default.error('There was an authentication error. Please login again');
                // Try to login and re-issue the command.
                loginPending = true;
                return run({ command: loginCmd }).then(() => {
                    clear_module_1.all();
                    main();
                }); // TODO: catch with different handler for second error
            }
            else {
                return; // Prevent multiple login attempts
            }
        }
        if (status >= 400) {
            const message = data ? data.message : null;
            const source = e.config.url;
            logger_1.default.error('API:', status, statusText);
            logger_1.default.error('Source:', source);
            if ((_k = e.config) === null || _k === void 0 ? void 0 : _k.method) {
                logger_1.default.error('Method:', e.config.method);
            }
            if (message) {
                logger_1.default.error('Message:', message);
                logger_1.default.debug('Raw error:', data);
            }
            else {
                logger_1.default.error('Raw error:', {
                    data,
                    source,
                });
            }
        }
        else {
            logger_1.default.error('Oops! There was an unexpected error:');
            logger_1.default.error(e.read ? e.read().toString('utf8') : data);
        }
    }
    else if (code) {
        switch (code) {
            case 'ENOTFOUND':
                logger_1.default.error('Connection failure :(');
                logger_1.default.error('Please check your internet');
                break;
            case 'EAI_AGAIN':
                logger_1.default.error('A temporary failure in name resolution occurred :(');
                break;
            default:
                logger_1.default.error('Unhandled exception');
                logger_1.default.error('Please report the issue in https://github.com/vtex/toolbelt/issues');
                if (((_l = e.config) === null || _l === void 0 ? void 0 : _l.url) && ((_m = e.config) === null || _m === void 0 ? void 0 : _m.method)) {
                    logger_1.default.error(`${e.config.method} ${e.config.url}`);
                }
                logger_1.default.debug(e);
        }
    }
    else {
        switch (e.name) {
            case findhelp_1.MissingRequiredArgsError.name:
                logger_1.default.error('Missing required arguments:', chalk_1.default.blue(e.message));
                break;
            case findhelp_1.CommandNotFoundError.name:
                logger_1.default.error('Command not found:', chalk_1.default.blue(...process.argv.slice(2)));
                break;
            case errors_1.CommandError.name:
                if (e.message && e.message !== '') {
                    logger_1.default.error(e.message);
                }
                break;
            case errors_1.SSEConnectionError.name:
                logger_1.default.error((_o = e.message, (_o !== null && _o !== void 0 ? _o : 'Connection to login server has failed')));
                break;
            case errors_1.UserCancelledError.name:
                logger_1.default.debug('User Cancelled');
                break;
            default:
                logger_1.default.error('Unhandled exception');
                logger_1.default.error('Please report the issue in https://github.com/vtex/toolbelt/issues');
                logger_1.default.error('Raw error:', e);
        }
    }
    process.exit(1);
};
axios_1.default.interceptors.request.use(config => {
    if (env_1.envCookies()) {
        config.headers.Cookie = `${env_1.envCookies()}; ${config.headers.Cookie || ''}`;
    }
    return config;
});
process.on('unhandledRejection', onError);
CLIPrechecker_js_1.CLIPrechecker.runChecks().then(() => {
    // Show update notification if newer version is available
    update_1.default();
    try {
        main().catch(onError);
    }
    catch (e) {
        onError(e);
    }
});
