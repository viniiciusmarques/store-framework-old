"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chokidar_1 = __importDefault(require("chokidar"));
const fs_extra_1 = require("fs-extra");
const globby_1 = __importDefault(require("globby"));
const path_1 = require("path");
const ramda_1 = require("ramda");
const logger_1 = __importDefault(require("../../logger"));
const defaultIgnored = [
    '.DS_Store',
    'README.md',
    '.gitignore',
    'package.json',
    'node_modules/**',
    '**/node_modules/**',
    '.git/**',
];
const services = ['react', 'render', 'masterdata', 'service'];
const safeFolder = folder => {
    if (folder && services.indexOf(folder) === -1) {
        logger_1.default.warn('Using unknown service', folder);
    }
    return folder ? './' + folder + '/**' : '*/**';
};
const isTestOrMockPath = (p) => /.*(test|mock|snapshot).*/.test(p.toLowerCase());
exports.getIgnoredPaths = (root, test = false) => {
    try {
        const filesToIgnore = fs_extra_1.readFileSync(path_1.join(root, '.vtexignore'))
            .toString()
            .split('\n')
            .map(p => p.trim())
            .filter(p => p !== '')
            .map(p => p.replace(/\/$/, '/**'))
            .concat(defaultIgnored);
        return test ? ramda_1.reject(isTestOrMockPath, filesToIgnore) : filesToIgnore;
    }
    catch (e) {
        return defaultIgnored;
    }
};
exports.listLocalFiles = (root, test = false, folder) => Promise.resolve(globby_1.default(['manifest.json', 'policies.json', 'node/.*', 'react/.*', `${safeFolder(folder)}`], {
    cwd: root,
    follow: true,
    ignore: exports.getIgnoredPaths(root, test),
    nodir: true,
}))
    .then((files) => Promise.all(files.map(file => fs_extra_1.lstat(path_1.join(root, file)).then(stats => ({ file, stats })))))
    .then(filesStats => filesStats.reduce((acc, { file, stats }) => {
    if (stats.size > 0) {
        acc.push(file);
    }
    return acc;
}, []));
exports.addChangeContent = (changes) => changes.map(({ path: filePath, action }) => {
    return {
        content: action === 'save' ? fs_extra_1.createReadStream(path_1.resolve(process.cwd(), filePath)) : null,
        path: filePath.split(path_1.sep).join('/'),
    };
});
const sendSaveChanges = (file, sendChanges) => sendChanges(exports.addChangeContent([{ path: file, action: 'save' }]));
const sendRemoveChanges = (file, sendChanges) => sendChanges(exports.addChangeContent([{ path: file, action: 'remove' }]));
exports.watch = (root, sendChanges, folder) => {
    const watcher = chokidar_1.default.watch([`${safeFolder(folder)}`, '*.json'], {
        atomic: true,
        awaitWriteFinish: {
            stabilityThreshold: 500,
        },
        cwd: root,
        ignoreInitial: true,
        ignored: exports.getIgnoredPaths(root),
        persistent: true,
        usePolling: true,
    });
    return new Promise((resolve, reject) => {
        watcher
            .on('add', (file, { size }) => (size > 0 ? sendSaveChanges(file, sendChanges) : null))
            .on('change', (file, { size }) => {
            return size > 0 ? sendSaveChanges(file, sendChanges) : sendRemoveChanges(file, sendChanges);
        })
            .on('unlink', file => sendRemoveChanges(file, sendChanges))
            .on('error', reject)
            .on('ready', resolve);
    });
};
