"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const async_retry_1 = __importDefault(require("async-retry"));
const chalk_1 = __importDefault(require("chalk"));
const ora_1 = __importDefault(require("ora"));
const ramda_1 = require("ramda");
const conf = __importStar(require("../../conf"));
const env_1 = require("../../env");
const errors_1 = require("../../errors");
const ProjectFilesManager_1 = require("../../lib/files/ProjectFilesManager");
const manifest_1 = require("../../lib/manifest");
const locator_1 = require("../../locator");
const logger_1 = __importDefault(require("../../logger"));
const manifest_2 = require("../../manifest");
const switch_1 = __importDefault(require("../auth/switch"));
const build_1 = require("../build");
const prompts_1 = require("../prompts");
const utils_1 = require("../utils");
const file_1 = require("./file");
const ProjectUploader_1 = require("./ProjectUploader");
const utils_2 = require("./utils");
const root = manifest_2.getAppRoot();
const buildersToRunLocalYarn = ['node', 'react'];
const automaticTag = (version) => (version.indexOf('-') > 0 ? null : 'latest');
const publisher = (workspace = 'master') => {
    const publishApp = async (appRoot, tag, force, projectUploader) => {
        const paths = await file_1.listLocalFiles(appRoot);
        const retryOpts = {
            retries: 2,
            minTimeout: 1000,
            factor: 2,
        };
        const publish = async (_, tryCount) => {
            const filesWithContent = ramda_1.map(ProjectFilesManager_1.createPathToFileObject(appRoot), paths);
            if (tryCount === 1) {
                logger_1.default.debug('Sending files:', '\n' + paths.join('\n'));
            }
            if (tryCount > 1) {
                logger_1.default.info(`Retrying...${tryCount - 1}`);
            }
            try {
                return await projectUploader.sendToPublish(filesWithContent, tag, { skipSemVerEnsure: force });
            }
            catch (err) {
                const response = err.response;
                const status = response.status;
                const data = response && response.data;
                const message = data.message;
                const statusMessage = status ? `: Status ${status}` : '';
                logger_1.default.error(`Error publishing app${statusMessage} (try: ${tryCount})`);
                if (message) {
                    logger_1.default.error(`Message: ${message}`);
                }
                if (status && status < 500) {
                    return;
                }
                throw err;
            }
        };
        return await async_retry_1.default(publish, retryOpts);
    };
    const publishApps = async (path, tag, force) => {
        const previousConf = conf.getAll(); // Store previous configuration in memory
        const manifest = await manifest_1.ManifestEditor.getManifestEditor();
        const account = conf.getAccount();
        const builderHubMessage = await utils_2.checkBuilderHubMessage('publish');
        if (!ramda_1.isEmpty(builderHubMessage)) {
            await utils_2.showBuilderHubMessage(builderHubMessage.message, builderHubMessage.prompt, manifest);
        }
        if (manifest.vendor !== account) {
            const switchToVendorMsg = `You are trying to publish this app in an account that differs from the indicated vendor. Do you want to publish in account ${chalk_1.default.blue(manifest.vendor)}?`;
            const canSwitchToVendor = await prompts_1.promptConfirm(switchToVendorMsg);
            if (!canSwitchToVendor) {
                throw new errors_1.UserCancelledError();
            }
            await switch_1.default(manifest.vendor, {});
        }
        const pubTag = tag || automaticTag(manifest.version);
        const appId = locator_1.toAppLocator(manifest);
        const context = { account: manifest.vendor, workspace, region: env_1.region(), authToken: conf.getToken() };
        const projectUploader = ProjectUploader_1.ProjectUploader.getProjectUploader(appId, context);
        const oraMessage = ora_1.default(`Publishing ${appId} ...`);
        const spinner = logger_1.default.level === 'debug' ? oraMessage.info() : oraMessage.start();
        try {
            const senders = ['vtex.builder-hub', 'apps'];
            const { response } = await build_1.listenBuild(appId, () => publishApp(path, pubTag, force, projectUploader), {
                waitCompletion: true,
                context,
                senders,
            });
            if (response.code !== 'build.accepted') {
                spinner.warn(`${appId} was published successfully, but you should update your builder hub to the latest version.`);
            }
            else {
                spinner.succeed(`${appId} was published successfully!`);
                logger_1.default.info(`You can deploy it with: ${chalk_1.default.blueBright(`vtex deploy ${appId}`)}`);
            }
        }
        catch (e) {
            spinner.fail(`Failed to publish ${appId}`);
        }
        await utils_1.switchToPreviousAccount(previousConf);
        Promise.resolve();
    };
    return { publishApp, publishApps };
};
exports.default = async (path, options) => {
    logger_1.default.debug(`Starting to publish app in ${conf.getEnvironment()}`);
    const manifest = await manifest_1.ManifestEditor.getManifestEditor();
    const versionMsg = chalk_1.default.bold.yellow(manifest.version);
    const appNameMsg = chalk_1.default.bold.yellow(`${manifest.vendor}.${manifest.name}`);
    const yesFlag = options.y || options.yes;
    if (!yesFlag) {
        const confirmVersion = await prompts_1.promptConfirm(`Are you sure that you want to release version ${chalk_1.default.bold(`${versionMsg} of ${appNameMsg}?`)}`, false);
        if (!confirmVersion) {
            process.exit(1);
        }
    }
    if (yesFlag && manifest.vendor !== conf.getAccount()) {
        logger_1.default.error(`When using the 'yes' flag, you need to be logged in to the same account as your appâ€™s vendor.`);
        process.exit(1);
    }
    path = path || root;
    const workspace = options.w || options.workspace;
    const force = options.f || options.force;
    // Always run yarn locally for some builders
    ramda_1.map(utils_1.runYarnIfPathExists, buildersToRunLocalYarn);
    const { publishApps } = publisher(workspace);
    await publishApps(path, options.tag, force);
};
